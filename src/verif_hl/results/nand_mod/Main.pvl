class Main { 
    //Auto-generated fields of the Main class:
    seq<int> process_state;
    seq<int> event_state;
    Nand_gate nand;
    Write_a nand_write_a;
    Write_b nand_write_b;
    Read nand_read;
    
    //Auto-generated global invariant: 
    inline resource scheduler_permission_invariant() = true ** 
            Perm(process_state, write) **
            |process_state| == 3 **
            Perm(event_state, write) **
            |event_state| == 3 **
            (\forall int i = 0 .. |process_state|; ((({: process_state[i] :} == -1)) || (((process_state[i] >= 0) && (process_state[i] < |event_state|))) ))
            ;
    inline resource global_permission_invariant() = true ** 
            scheduler_permission_invariant() **
            Perm(nand, read) **
            (nand != null) **
            Perm(nand.A, write) **
            Perm(nand.B, write) **
            Perm(nand.out, write) **
            Perm(nand_write_a, read) **
            (nand_write_a != null) **
            Perm(nand_write_a.a, write) **
            Perm(nand_write_b, read) **
            (nand_write_b != null) **
            Perm(nand_write_b.b, write) **
            Perm(nand_read, read) **
            (nand_read != null) **
            Perm(nand.m, read) **
            (nand.m == this)
            ;
    resource lock_invariant() = global_permission_invariant();
    
    //Auto-generated constructor:
    //Auto-generated specifications of the constructor Main:
    Main(){
        process_state = [-1,-1,-1];
        //
        event_state = [-3,-3,-3];
        nand = new Nand_gate(this);
        nand_write_a = new Write_a(this);
        nand_write_b = new Write_b(this);
        nand_read = new Read(this);
    }
    
    
    //Auto-generated functions:
    //Auto-generated specifications of the function main:
    void main(){
        lock this;
        fork nand_write_a;
        fork nand_write_b;
        fork nand_read;
        unlock this;
        loop_invariant true ;
        while (true) {
            lock this;
            immediate_wakeup();
            reset_events_no_delta();
            if (process_state[0] != -1 && process_state[1] != -1 && process_state[2] != -1 ) {
                int min_advance = find_minimum_advance(event_state);
                if (min_advance == -1) {
                    min_advance = 0;
                }
                event_state = [event_state[0] < -1 ? -3 : event_state[0] - min_advance,event_state[1] < -1 ? -3 : event_state[1] - min_advance,event_state[2] < -1 ? -3 : event_state[2] - min_advance];
                wakeup_after_wait();
                reset_all_events();
            }
            unlock this;
        }
        join nand_write_a;
        join nand_write_b;
        join nand_read;
    }
    
    //Auto-generated specifications of the function immediate_wakeup:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((event_state == \old(event_state))) );
    ensures ((((((\old(process_state[0]) >= 0)) && ((\old(event_state[\old(process_state[0])]) == 0)) ) ==> (((process_state[0] == -1)) ))) && (((((\old(process_state[1]) >= 0)) && ((\old(event_state[\old(process_state[1])]) == 0)) ) ==> (((process_state[1] == -1)) ))) && (((((\old(process_state[2]) >= 0)) && ((\old(event_state[\old(process_state[2])]) == 0)) ) ==> (((process_state[2] == -1)) ))) );
    ensures (((!(((\old(process_state[0]) >= 0)) && ((\old(event_state[\old(process_state[0])]) == 0)) ) ==> (((process_state[0] == \old(process_state[0]))) ))) && ((!(((\old(process_state[1]) >= 0)) && ((\old(event_state[\old(process_state[1])]) == 0)) ) ==> (((process_state[1] == \old(process_state[1]))) ))) && ((!(((\old(process_state[2]) >= 0)) && ((\old(event_state[\old(process_state[2])]) == 0)) ) ==> (((process_state[2] == \old(process_state[2]))) ))) );
    void immediate_wakeup();
    
    //Auto-generated specifications of the function reset_events_no_delta:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((process_state == \old(process_state))) );
    ensures ((((((\old(event_state[0]) == 0)) ) ==> (((event_state[0] == -2)) ))) && (((((\old(event_state[1]) == 0)) ) ==> (((event_state[1] == -2)) ))) && (((((\old(event_state[2]) == 0)) ) ==> (((event_state[2] == -2)) ))) );
    ensures (((!(((\old(event_state[0]) == 0)) ) ==> (((event_state[0] == \old(event_state[0]))) ))) && ((!(((\old(event_state[1]) == 0)) ) ==> (((event_state[1] == \old(event_state[1]))) ))) && ((!(((\old(event_state[2]) == 0)) ) ==> (((event_state[2] == \old(event_state[2]))) ))) );
    void reset_events_no_delta();
    
    //Auto-generated specifications of the function find_minimum_advance:
    requires (|vals| == 3);
    ensures ((((vals[0] < -1) || (\result <= vals[0]))) && (((vals[1] < -1) || (\result <= vals[1]))) && (((vals[2] < -1) || (\result <= vals[2]))) );
    ensures (((((vals[0] < -1)) && ((vals[1] < -1)) && ((vals[2] < -1)) ) ==> (\result == 0)) && ((((vals[0] >= -1)) || ((vals[1] >= -1)) || ((vals[2] >= -1)) ) ==> ((((vals[0] >= -1) && (\result == vals[0]))) || (((vals[1] >= -1) && (\result == vals[1]))) || (((vals[2] >= -1) && (\result == vals[2]))) )));
    pure int find_minimum_advance(seq<int> vals);
    
    //Auto-generated specifications of the function wakeup_after_wait:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((event_state == \old(event_state))) );
    ensures ((((((\old(process_state[0]) >= 0)) && (((\old(event_state[\old(process_state[0])]) == 0) || (\old(event_state[\old(process_state[0])]) == -1))) ) ==> (((process_state[0] == -1)) ))) && (((((\old(process_state[1]) >= 0)) && (((\old(event_state[\old(process_state[1])]) == 0) || (\old(event_state[\old(process_state[1])]) == -1))) ) ==> (((process_state[1] == -1)) ))) && (((((\old(process_state[2]) >= 0)) && (((\old(event_state[\old(process_state[2])]) == 0) || (\old(event_state[\old(process_state[2])]) == -1))) ) ==> (((process_state[2] == -1)) ))) );
    ensures (((!(((\old(process_state[0]) >= 0)) && (((\old(event_state[\old(process_state[0])]) == 0) || (\old(event_state[\old(process_state[0])]) == -1))) ) ==> (((process_state[0] == \old(process_state[0]))) ))) && ((!(((\old(process_state[1]) >= 0)) && (((\old(event_state[\old(process_state[1])]) == 0) || (\old(event_state[\old(process_state[1])]) == -1))) ) ==> (((process_state[1] == \old(process_state[1]))) ))) && ((!(((\old(process_state[2]) >= 0)) && (((\old(event_state[\old(process_state[2])]) == 0) || (\old(event_state[\old(process_state[2])]) == -1))) ) ==> (((process_state[2] == \old(process_state[2]))) ))) );
    void wakeup_after_wait();
    
    //Auto-generated specifications of the function reset_all_events:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((process_state == \old(process_state))) );
    ensures (((((\old(event_state[0]) == 0) || (\old(event_state[0]) == -1)) ==> (((event_state[0] == -2)) ))) && ((((\old(event_state[1]) == 0) || (\old(event_state[1]) == -1)) ==> (((event_state[1] == -2)) ))) && ((((\old(event_state[2]) == 0) || (\old(event_state[2]) == -1)) ==> (((event_state[2] == -2)) ))) );
    ensures (((!((\old(event_state[0]) == 0) || (\old(event_state[0]) == -1)) ==> (((event_state[0] == \old(event_state[0]))) ))) && ((!((\old(event_state[1]) == 0) || (\old(event_state[1]) == -1)) ==> (((event_state[1] == \old(event_state[1]))) ))) && ((!((\old(event_state[2]) == 0) || (\old(event_state[2]) == -1)) ==> (((event_state[2] == \old(event_state[2]))) ))) );
    void reset_all_events();
    
}

