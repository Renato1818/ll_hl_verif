







//------------------------------------------------------------------------------
// All settings for the environment model
// for the test cases "Beschleunigungsfahrt" and "Vollbremsung"
// 
// Autor:    Tammo Mathias Stupp
// 
// erstellt: 2008-06-22
// geändert: 2008-07-03
//------------------------------------------------------------------------------




//------------------------------------------------------------------------------
// Konstanten
//------------------------------------------------------------------------------
                // used to find reference velocity

//#define VELOFACTOR 754 // v = s/t = Ticks/50 * freq * 2 * pi * r = 0.754 * Ticks [m/s] = 754 * Ticks [mm/s]  




SC_MODULE ( TickCounter ) {

//-*-*-*-*-*-*-*-*-*-*-*-*  INTERFACE  *-*-*-*-*-*-*-*-*-*-*-*-

  sc_fifo_out<int> out;

//-*-*-*-*-*-*-*-*-*-*-*-* LOCAL VARIABLES *-*-*-*-*-*-*-*-*-*-*-*-
  int ticks; // Counter

//-*-*-*-*-*-*-*-*-*-*-*-*-* COUNTER *-*-*-*-*-*-*-*-*-*-*-*-*-

  /* void count(){

    if (reset.read())

      ticks = 0;

    else

      ticks = ticks + 1;

      }*/
//-*-*-*-*-*-*-*-*-*-*-*-*-* SENDER *-*-*-*-*-*-*-*-*-*-*-*-*-

  // read ticks in a given time interval and send to ECU
  void send(){
    int speed;

    srand(time(NULL));
    while(true){
      wait(1, SC_MS);
/* #ifdef DEBUG */
/* 	cout << sc_time_stamp() << " trying to send to ECU: " << ticks << endl; */
/* #endif */
      speed = rand();
      out.write(speed); // zur ECU schicken  
/* #ifdef DEBUG */
/* 	cout << sc_time_stamp() << " send to the ECU: " << ticks << endl; */
/* #endif */
//	ticks = 0; 
    }
  }

//-*-*-*-*-*-*-*-*-*-*-*-*-*-* CONSTRUCTOR *-*-*-*-*-*-*-*-*-*-*-*-*-*-

  SC_CTOR(TickCounter) {
    //    SC_METHOD(count);
    //sensitive << inTicks;
    SC_THREAD(send);

  }

};

/* This is a simple Anti-lock Braking System. The inputs are the

   number of ticks counted within 100 ms at each wheel. Outputs are

   control signals for pressure control (0 - constant pressure, 2 -

   increase pressure, 1 - increase pressure slightly, -1 - decrease

   pressure).



   would be better: move conversion from ticks to velocity to other

   modules, would be easier then to argue with a real refinement

   process (communication, data and time refinement)

*/

//------------------------------------------------------------------------------
// All settings for the environment model
// for the test cases "Beschleunigungsfahrt" and "Vollbremsung"
// 
// Autor:    Tammo Mathias Stupp
// 
// erstellt: 2008-06-22
// geändert: 2008-07-03
//------------------------------------------------------------------------------




SC_MODULE ( ABSASR ) {

//-*-*-*-*-*-*-*-*-*-*-*-*  INTERFACE  *-*-*-*-*-*-*-*-*-*-*-*-

  sc_fifo_in<int> bus_vl;
  sc_fifo_in<int> bus_vr;
  sc_fifo_in<int> bus_hl;
  sc_fifo_in<int> bus_hr;

//-*-*-*-*-*-*-*-*-*-*-*-* LOCAL VARIABLES *-*-*-*-*-*-*-*-*-*-*-*-

//  int ticks_vr, ticks_vl, ticks_hr, ticks_hl;
  int v[4], a[4]; // current wheel velocity and acceleration
  int temp_fv, fv; // estimated vehicle velocity
  int fa; // estimated vehicle acceleration
  int lambda[4]; // Slippage at each wheel
  int s[4]; // ABS state per wheel
  int p[4]; // Braking pressure command (see above)

  // ABS Routine
  void _ABS(){

    if(fv > 22){ // ABS is only active above a threshold velocity





      for(int i = 0; i < 4; i = i + 1){
        lambda[i] = ((fv-v[i])*100)/fv;







        switch(s[i]){
          case 1:
            if (a[i] < -14){
              p[i] = 0;
              s[i] = 2;
            }
            break;
          case 2:
            if (lambda[i] > 13){
              p[i] = -1;
              s[i] = 3;
            }
            break;
          case 3:
            if (a[i] > -14){
              p[i] = 0;
              s[i] = 4;
            }
            break;
          case 4:
            if (a[i] > 98){
              p[i] = 2;
              s[i] = 5;
            }
            break;
          case 5:
            if (a[i] < 98){
              p[i] = 0;
              s[i] = 6;
            }
            break;
          case 6:
            if (a[i] < 2){
              p[i] = 1;
              s[i] = 7;
            }
            break;
          case 7:
            if (a[i] < -14){
              p[i] = -1;
              s[i] = 8;
            }
            break;
          case 8:
            if (a[i] > -14){
              p[i] = 0;
              s[i] = 4;
            }
            break;
        }
      }
    }
  }

  // ASR Routine
  void _ASR(){

    int j = 3; // the first comparison is vl (0) with hr (3)
               // ASR assumes front wheel drive

    for(int i = 0; i < 2; i = i + 1){

      if(v[i] > 0){
        lambda[i] = ((v[i]-v[j])*100)/v[i];

        if(lambda[i] > 13){ // Slippage too high -> brake
          if(a[i] > 0){
            p[i] = 2; // Increase pressure
          }
          else{
            p[i] = 0; // Keep pressure constant
          }
        }
        else{ // No slippage -> release brakes
          p[i] = -1; // Release braking pressure
        }
      }
      j = 2; // the second comparison is vr (1) with hl (2)
    }
  }

  int abs(int val)
    {
      if (val >= 0)
        return val;
      else
        return -val;
    }

  void not_a_main()
    {
      int i;
      // INIT
      for(i = 0; i < 4; i=i+1){
        s[i] = 1;
        v[i] = 0;
        a[i] = 0;
      }

      while(true){
        wait(1,SC_MS);

        // Take the velocity of the wheel with the lowest acceleration as a reference for the vehicle velocity
        i = 0;
        if(abs(a[1]) < abs(a[i]))
          i = 1;
        if(abs(a[2]) < abs(a[i]))
          i = 2;
        if(abs(a[3]) < abs(a[i]))
          i = 3;

        temp_fv = v[i];
        fa = temp_fv - fv;
        if( fa < 0 ){ //  deceleration
          if(fa < -14){ // all wheels are locked -> use different estimation for vehicle velocity
            fv=fv+-2; // estimated optimal deceleration





          }
          else
            fv = temp_fv;
          _ABS();
        }
        else if (fa > 0){
          fv = temp_fv;
          _ASR();
        }
      }
    }

  void read_speed()
    {
      int tmp_0 = 0;
      int tmp_1 = 0;
      int tmp_2 = 0;
      int tmp_3 = 0;
      while(true){
        v[0] = bus_vr.read();





        //  v[0] = VELOFACTOR * ticks_vr;
        a[0] = (v[0] - tmp_0); //*VELOFACTOR;
        tmp_0 = v[0];

        // ----------------------------------

        v[1] = bus_vl.read();





        //	  v[1] = VELOFACTOR * v[1];
        a[1] = (v[1] - tmp_1); //*VELOFACTOR;
        tmp_1 = v[1];

        // ----------------------------------

        v[2] = bus_hr.read();





        //	  v[2] = VELOFACTOR * v[2];
        a[2] = (v[2] - tmp_2); //*VELOFACTOR;
        tmp_2 = v[2];

        // ----------------------------------

        v[3] = bus_hl.read();





        //	  v[3] = VELOFACTOR * v[3];
        a[3] = (v[3] - tmp_3); //*VELOFACTOR;
        tmp_3 = v[3];
      }
    }

//-*-*-*-*-*-*-*-*-*-*-*-*-*-* KONSTRUKTOR *-*-*-*-*-*-*-*-*-*-*-*-*-*-

  SC_CTOR( ABSASR ){
    SC_THREAD(not_a_main);
    // read in the ticks and calculate a and v
    SC_THREAD(read_speed);
  }
};

int sc_main (int argc, char* argv[])
{
  //  sc_signal<bool>         resetWheels;   

  sc_fifo< int > speed_vl, speed_vr, speed_hl, speed_hr;


  //  inp.resetAll(resetWheels);

  TickCounter vl("vl");
    vl.out( speed_vl );


   TickCounter vr("vr");
    vr.out( speed_vr );

  TickCounter hl("hl");
    hl.out( speed_hl );


  TickCounter hr("hr");
    hr.out( speed_hr );


  ABSASR ecu_absasr("absasr");
    ecu_absasr.bus_vl( speed_vl );
    ecu_absasr.bus_vr( speed_vr );
    ecu_absasr.bus_hl( speed_hl );
    ecu_absasr.bus_hr( speed_hr );
  sc_start(20,SC_MS); // Run the simulation till sc_stop is encountered

  //sc_close_vcd_trace_file(wf);

  return 0; // Terminate simulation

}
