class ALU { 
    Main m;
    boolean init;

	int OPCODE;
	int OP1;
	int OP2;
	boolean CARRY;
	boolean ZERO;
	int RESULT;

    ensures Perm(m, write) **
            Perm(OPCODE, write) **
            Perm(OP1, write) **  OP1 == 0 **
            Perm(OP2, write) **  OP2 == 0 **
            Perm(CARRY, write) ** !CARRY **
            Perm(ZERO, write) ** !ZERO **
            Perm(RESULT, write) ** RESULT == 0 **
            (m == m_param) ;
    ALU(Main m_param){
        m = m_param;

        OPCODE = 0;
	    OP1 = 0;
	    OP2 = 0;
	    CARRY = false;
	    ZERO = false;
	    RESULT = 0;

    }
    
    
    context Perm(m, read)
        ** m != null
        ** held(m)  
        ** m.global_permission_invariant() 
        ** Perm(m.alu, read)
        ** m.alu == this  ;
    ensures \result >= 0 && \result < 16; // 2^4
    int get_bit(int value, int pos){
        int i;
        int divisor;
        divisor = 1;
        loop_invariant true 
            ** Perm(m, read) 
            ** (m != null) 
            ** held(m)  
            ** m.global_permission_invariant() 
            ** (m.alu == this) ;
        for (i = 0; i < pos; i++) {
            divisor = divisor * 2;
        }
        if (divisor != 0) {
            return (value / divisor) % 2;
        } else {
            return 0;
        }
    }

    
    context Perm(m, read)
        ** m != null
        ** held(m)  
        ** m.global_permission_invariant()
        ** Perm(m.alu, read)
        ** m.alu == this
        ;
    int set_bit(int value, int pos, int bit){
        int i;
        int divisor;
        int current_bit;
        current_bit = m.alu.get_bit(value, pos);
        divisor = 1;
        loop_invariant true 
            ** Perm(m, read) 
            ** (m != null) 
            ** held(m)  
            ** m.global_permission_invariant() 
            ** (m.alu == this)   
            ;
        for (i = 0; i < pos; i++) {
            divisor = divisor * 2;
        }
        if (current_bit == bit) {
            return value;
        } else {
            if (bit == 1) {
                return value + divisor;
            } else {
                return value - divisor;
            }
        }
    }

    context Perm(m, read)
        ** m != null
        ** held(m)  
        ** m.global_permission_invariant()
        ** Perm(m.alu, read)
        ** m.alu == this   ;
    void operate(){
        int i;
        int data1;
        int data2;
        int result;
        int bit;
        loop_invariant true 
            ** Perm(m, read) 
            ** (m != null) 
            ** held(m)  
            ** m.global_permission_invariant() 
            ** (m.alu == this)   
            //** (((OPCODE % 8) == 0) ==> \old(result) == \old(data1) + \old(data2))
            //** ((OPCODE == 1) ==> \old(result) == \old(data1) - \old(data2))
            //** ((OPCODE == 2) ==> \old(result) == \old(data1) + 1)
            //** ((OPCODE == 3) ==> \old(result) == \old(data1) - 1) 
            ;  
        while (true) {
            ZERO = false;
            data1 = OP1 % 16;
            data2 = OP2 % 16;
            if ( (OPCODE % 8) == 0) {
                result = data1 + data2;
            } else {
                if ((OPCODE % 8)  == 1) {
                    result = data1 - data2;
                } else {
                    if ((OPCODE % 8)  == 2) {
                        result = data1 + 1;
                    } else {
                        if ((OPCODE % 8)  == 3) {
                            result = data1 - 1;
                        } else {
                            if ((OPCODE % 8)  == 4) {
                                loop_invariant true 
                                    ** Perm(m, read) 
                                    ** (m != null) 
                                    ** held(m)  
                                    ** m.global_permission_invariant() 
                                    ** (m.alu == this)   
                                    ;
                                for (i = 0; i < 4; i++) {
                                    bit = get_bit(data1, i) * get_bit(data2, i);
                                    result = set_bit(result, i, bit);
                                }
                            } else {
                                if ((OPCODE % 8)  == 5) {
                                    loop_invariant true 
                                        ** Perm(m, read) 
                                        ** (m != null) 
                                        ** held(m)  
                                        ** m.global_permission_invariant() 
                                        ** (m.alu == this)     
                                        ;
                                    for (i = 0; i < 4; i++) {
                                        bit = get_bit(data1, i) + get_bit(data2, i);
                                        result = set_bit(result, i, (bit > 0) ? 1 : 0 );
                                    }
                                } else {
                                    if ((OPCODE % 8)  == 6) {
                                        loop_invariant true 
                                            ** Perm(m, read) 
                                            ** (m != null) 
                                            ** held(m)  
                                            ** m.global_permission_invariant() 
                                            ** (m.alu == this)     
                                            ;
                                        for (i = 0; i < 4; i++) {
                                            bit = get_bit(data1, i) * get_bit(data2, i);
                                            result = set_bit(result, i, (bit == 1) ? 0 : 1);
                                        }
                                    } else {
                                        if ((OPCODE % 8)  == 7) {
                                            loop_invariant true 
                                                ** Perm(m, read) 
                                                ** (m != null) 
                                                ** held(m)  
                                                ** m.global_permission_invariant() 
                                                ** (m.alu == this) 
                                                ;
                                            for (i = 0; i < 4; i++) {
                                                bit = get_bit(data1, i) + get_bit(data2, i);
                                                result = set_bit(result, i, (bit == 1) ? 1 : 0 );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            RESULT == result % 16;
            CARRY = ((result / 16) % 2) == 1 ? true : false;
            
            if ( (result % 16) == 0) {
                ZERO = true;
            }
        }
    }
}

class Driver { 
    //Auto-generated fields of the Driver class:
    Main m;
    boolean init;

    int z;
    int x;
    int y;
    int a;
    
    //Auto-generated constructor:
    //Auto-generated specifications of the constructor Driver:
    ensures Perm(m, write) **
            Perm(init, write) ** !init **
            Perm(z, write) **
            Perm(x, write) **
            Perm(y, write) **
            Perm(a, write) **
            (m == m_param) ;
    Driver(Main m_param){
        m = m_param;    
        init = false;
    }
    
    
    //Auto-generated functions:
    //Auto-generated specifications of the function run:
    context Perm(m, 1\2)
        ** m != null
        ** Perm(m.dr, read)
        ** m.dr == this
        ** Perm(init, 1\2)
        ** !init;
    void run(){
        lock m;
        init = true;
        
        z = 0;
        x = 0;
        y = 0;

        loop_invariant true 
            ** Perm(m, 1\2) 
            ** (m != null) 
            ** held(m)  
            ** m.global_permission_invariant() 
            ** (m.dr == this)            
            ** Perm(init, 1\2)
            ** init;
        while (true) {
            loop_invariant true 
                ** Perm(m, 1\2) 
                ** (m != null) 
                ** held(m)  
                ** m.global_permission_invariant() 
                ** (m.dr == this)            
                ** Perm(init, 1\2)
                ** init;
            for (a = 0; a < 8; a++) {
                y++;
                x = 16 - y;
                m.alu.OPCODE = z;
                m.alu.OP1 = x;
                m.alu.OP2 = y;
                z++;
                m.process_state = m.process_state[0 -> 0];
                m.event_state = m.event_state[0 -> 5];
                loop_invariant true 
                    ** Perm(m, 1\2) 
                    ** (m != null) 
                    ** held(m)  
                    ** m.global_permission_invariant() 
                    ** (m.dr == this)            
                    ** Perm(init, 1\2)
                    ** init;
                while (m.process_state[0] != -1 || m.event_state[0] != -2) {
                    unlock m;
                    lock m;
                }
            }
            if (z == 8) {
                z = 0;
            }
            if (y == 16) {
                y = 0;
            }
        }
        unlock m;
    }
    
}


class Monitor { 
    //Auto-generated fields of the Monitor class:
    Main m;
    boolean init;
    
    //Auto-generated constructor:
    //Auto-generated specifications of the constructor Monitor:
    ensures Perm(m, write) **
            Perm(init, write) ** !init **
            (m == m_param) ;
    Monitor(Main m_param){
        m = m_param;
        init = false;
    }
    
    
    //Auto-generated functions:
    //Auto-generated specifications of the function main_method:
    context Perm(m, 1\2)
        ** m != null
        ** Perm(m.mon, read)
        ** m.mon == this
        ** Perm(init, 1\2)
        ** !init;
    //requires ((0 <= process_id) && (process_id < |m.process_state|));
    void run(){
        lock m;
        init = true;

        loop_invariant true 
            ** Perm(m, 1\2) 
            ** (m != null) 
            ** held(m)  
            ** m.global_permission_invariant() 
            ** (m.mon == this)            
            ** Perm(init, 1\2)
            ** init;
        while (true) {
            m.process_state = m.process_state[0 -> 1];
            loop_invariant true 
                ** Perm(m, 1\2) 
                ** (m != null) 
                ** held(m)  
                ** m.global_permission_invariant() 
                ** (m.mon == this)            
                ** Perm(init, 1\2)
                ** init;
            while (m.process_state[0] != -1 || m.event_state[1] != -2) {
                unlock m;
                lock m;
            }
        }

        unlock m;
    }
    
}



class Main { 
    //Scheduling state
    seq<int> process_state;
    seq<int> event_state;

    // Object instances
    ALU alu;
    Driver dr;
    Monitor mon;
    
    //Auto-generated global invariant: 
    inline resource scheduler_permission_invariant() = true 
        ** Perm(process_state, write) 
        ** |process_state| == 1 
        ** Perm(event_state, write) 
        ** |event_state| == 2 
        
        ** (\forall int i = 0 .. |process_state|; 
            ((({: process_state[i] :} == -1)) || (((process_state[i] >= 0) && 
            (process_state[i] < |event_state|))) )) ;
    
    inline resource global_permission_invariant() = true 
            ** scheduler_permission_invariant() 

            //ALU
            ** Perm(alu, read) 
            ** (alu != null) 
            ** Perm(alu.OPCODE, write) 
            //** 0 <= alu.OPCODE
            //** alu.OPCODE <= 8
            ** Perm(alu.OP1, write) 
            //** 0 <= alu.OP1
            //** alu.OP1 <= 16
            ** Perm(alu.OP2, write) 
            //** 0 <= alu.OP2
            //** alu.OP2 <= 16
            ** Perm(alu.CARRY, write) 
            ** Perm(alu.ZERO, write) 
            ** Perm(alu.RESULT, write) 
            ** 0 <= alu.RESULT
            ** alu.RESULT <= 16

            //Driver
            ** Perm(dr, read) 
            ** (dr != null) 
            ** Perm(dr.init, 1\2) 
            ** Perm(dr.z, write) 
            ** Perm(dr.x, write) 
            ** Perm(dr.y, write) 
            ** Perm(dr.a, write) 

            //Monitor
            ** Perm(mon, read) 
            ** (mon != null) 
            ** Perm(mon.init, 1\2) 
            ** Perm(alu.m, read) 
            ** (alu.m == this) 
            //Perm(mon.m, read) **
            //(mon.m == this)
            ; 

    inline resource alu_permission_inv() = true
            // USER-DEFINED INVARIANTS
            //** (fifo.r_pos < fifo.w_pos ==> fifo.n == fifo.w_pos - fifo.r_pos)
            ** ((alu.OPCODE == 0) ==> alu.RESULT == alu.OP1 + alu.OP2)
            ** ((alu.OPCODE == 1) ==> alu.RESULT == alu.OP1 - alu.OP2)
            ** ((alu.OPCODE == 2) ==> alu.RESULT == alu.OP1 + 1)
            ** ((alu.OPCODE == 3) ==> alu.RESULT == alu.OP1 - 1)
            ; 

    resource lock_invariant() = global_permission_invariant();
    
    //Auto-generated constructor:
    //Auto-generated specifications of the constructor Main:
    ensures Perm(dr, read)
            ** dr != null
            ** Perm(dr.m, 1\2)
            ** dr.m == this
            ** Perm(dr.init, 1\2)
            ** !dr.init
            //** Perm(alu, read)
            //** Perm(alu.OPCODE, 1\2)
            //** Perm(alu.OP1, 1\2)
            //** Perm(alu.OP2, 1\2)           
            ;
    ensures Perm(mon, read)
            ** mon != null
            ** Perm(mon.m, 1\2)
            ** mon.m == this
            ** Perm(mon.init, 1\2)
            ** !mon.init
            //** Perm(alu.RESULT, 1\2)
            //** Perm(alu.CARRY, 1\2)
            //** Perm(alu.ZERO, 1\2)
            ;
    ensures idle(dr);
    ensures idle(mon);
    Main(){
        process_state = [-1];
        event_state = [-3,-3];
        
        alu = new ALU(this);
        dr = new Driver(this);
        mon = new Monitor(this);
    }
    
    
    //Auto-generated functions:
    //Auto-generated specifications of the function main:
    context Perm(dr, read)
            ** dr != null
            ** Perm(dr.m, 1\2)
            ** dr.m == this
            ** Perm(dr.init, 1\2)
            ** !dr.init;
    context Perm(mon, read)
            ** mon != null
            ** Perm(mon.m, 1\2)
            ** mon.m == this
            ** Perm(mon.init, 1\2)
            ** !mon.init;
    context idle(dr);
    context idle(mon);
    void main(){
        lock this;
        fork dr;
        fork mon;
        unlock this;

        loop_invariant true ;
        while (true) {
            lock this;
            immediate_wakeup();
            reset_events_no_delta();
            if (process_state[0] != -1 ) {
                int min_advance = find_minimum_advance(event_state);
                if (min_advance == -1) {
                    min_advance = 0;
                }
                event_state = [event_state[0] < -1 ? -3 : event_state[0] - min_advance,
                    	       event_state[1] < -1 ? -3 : event_state[1] - min_advance];
                
                wakeup_after_wait();
                reset_all_events();
            }
            unlock this;
        }
        
        join dr;
        join mon;
    }
    
    //Auto-generated specifications of the function immediate_wakeup:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((event_state == \old(event_state))) );
    ensures ((((((\old(process_state[0]) >= 0)) && ((\old(event_state[\old(process_state[0])]) == 0)) ) ==> (((process_state[0] == -1)) ))) );
    ensures (((!(((\old(process_state[0]) >= 0)) && ((\old(event_state[\old(process_state[0])]) == 0)) ) ==> (((process_state[0] == \old(process_state[0]))) ))) );
    void immediate_wakeup();
    
    //Auto-generated specifications of the function reset_events_no_delta:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((process_state == \old(process_state))) );
    ensures ((((((\old(event_state[0]) == 0)) ) ==> (((event_state[0] == -2)) ))) && (((((\old(event_state[1]) == 0)) ) ==> (((event_state[1] == -2)) ))) );
    ensures (((!(((\old(event_state[0]) == 0)) ) ==> (((event_state[0] == \old(event_state[0]))) ))) && ((!(((\old(event_state[1]) == 0)) ) ==> (((event_state[1] == \old(event_state[1]))) ))) );
    void reset_events_no_delta();
    
    //Auto-generated specifications of the function find_minimum_advance:
    requires (|vals| == 2);
    ensures ((((vals[0] < -1) || (\result <= vals[0]))) && (((vals[1] < -1) || (\result <= vals[1]))) );
    ensures (((((vals[0] < -1)) && ((vals[1] < -1)) ) ==> (\result == 0)) && ((((vals[0] >= -1)) || ((vals[1] >= -1)) ) ==> ((((vals[0] >= -1) && (\result == vals[0]))) || (((vals[1] >= -1) && (\result == vals[1]))) )));
    pure int find_minimum_advance(seq<int> vals);
    
    //Auto-generated specifications of the function wakeup_after_wait:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((event_state == \old(event_state))) );
    ensures ((((((\old(process_state[0]) >= 0)) && (((\old(event_state[\old(process_state[0])]) == 0) || (\old(event_state[\old(process_state[0])]) == -1))) ) ==> (((process_state[0] == -1)) ))) );
    ensures (((!(((\old(process_state[0]) >= 0)) && (((\old(event_state[\old(process_state[0])]) == 0) || (\old(event_state[\old(process_state[0])]) == -1))) ) ==> (((process_state[0] == \old(process_state[0]))) ))) );
    void wakeup_after_wait();
    
    //Auto-generated specifications of the function reset_all_events:
    context held(this) **
            scheduler_permission_invariant() ;
    ensures (((process_state == \old(process_state))) );
    ensures (((((\old(event_state[0]) == 0) || (\old(event_state[0]) == -1)) ==> (((event_state[0] == -2)) ))) && ((((\old(event_state[1]) == 0) || (\old(event_state[1]) == -1)) ==> (((event_state[1] == -2)) ))) );
    ensures (((!((\old(event_state[0]) == 0) || (\old(event_state[0]) == -1)) ==> (((event_state[0] == \old(event_state[0]))) ))) && ((!((\old(event_state[1]) == 0) || (\old(event_state[1]) == -1)) ==> (((event_state[1] == \old(event_state[1]))) ))) );
    void reset_all_events();
    
}

